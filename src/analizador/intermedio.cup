/* ---------------Seccion de declaraciones preliminares--------------------*/
package analizador;

/* -------------Importaciones -------------  */
import java.io.*;
import java.lang.*;
import java_cup.runtime.*;
import java_cup.runtime.Symbol;
import java.util.ArrayList;
import java.util.*;



/***********ACTION CODE***********/
action code{:
void print(String msj)
   {System.out.println(msj);}
:}
/* Codigo del parser, se copia integramente a la clase final. Agregamos el manejo de errores. */

/**********PARSER CODE***********/
parser code {:
    
    boolean esId;
    String tipoActual;
    String salidaTipoActual;
    Object valorActual;
    String valorActualTipo;
    String fil,col;
    ArrayList<Error1> ManejadorDeErrores;
    int fl;
    int op_relacional=0;
    boolean esDAssig=false;

    public String generarSinTemp(String tipo, String op1,String op2){
    String codigo="";
    switch(tipo){
        case "ASIG": 
            codigo = Generador.gc(Generador.ASIG, op1, null, op2);
            break;

        }
        FCompiler.codigointermedio += codigo; 
        return op2;
    }
    
    public String generar(String tipo, String op1,String op2){
    String t="";
    String t2="";
    String codigo="";
    switch(tipo){
        case "PRINTLN":
            System.out.println("Entro a imprimir");        
                codigo = Generador.gc(Generador.PRINTLN, null, null, op2);     
            break;
        case "ADD_OP": 
            t = Generador.nuevaTemp();
            codigo = Generador.gc(Generador.ADD_OP, op1, op2, t);
            break;
        case "SUBS_OPP": 
            t = Generador.nuevaTemp();
            codigo = Generador.gc(Generador.SUBS_OPP, op1, op2, t);
            break;
        case "OP_REL":
            switch(op_relacional){
                case 6: 
                    t = Generador.nuevaTemp();
                    codigo = Generador.gc(Generador.GREATER_OP, op1, op2, t);
                    break;
                case 2: 
                    t = Generador.nuevaTemp();
                    codigo = Generador.gc(Generador.GREATER_EQUAL_OP, op1, op2, t);
                    break;
                case 1: 
                    t = Generador.nuevaTemp();
                    codigo = Generador.gc(Generador.EQUAL_OP, op1, op2, t);
                    break;
                case 3: 
                    t = Generador.nuevaTemp();
                    codigo = Generador.gc(Generador.LESS_EQUAL_OP, op1, op2, t);
                    break;
                case 5: 
                    t = Generador.nuevaTemp();
                    codigo = Generador.gc(Generador.LESS_OP, op1, op2, t);
                    break;
                case 4: 
                    t = Generador.nuevaTemp();
                    codigo = Generador.gc(Generador.NOT_EQUAL_OP, op1, op2, t);
                    break;
                }
            break;
       /* case "RECIBIR":
            codigo = Generador.gc(Generador.RECIBIR, null, null, op2);
            break;
        case "RECIBIR2":
            t = Generador.nuevaTemp();
            if(tipoPrint==0){
            codigo = Generador.gc(Generador.RECIBIR, null, null, op1);}
            else{
                if(tipoPrint==2){codigo = Generador.gc(Generador.RECIBIR3, null, null, op1);//Impresion de string
                    }else{
                codigo = Generador.gc(Generador.RECIBIR2, null, null, op1);
                }
            }
            codigo += Generador.gc(Generador.ASIG, op1, null, t);
            break;
        case "INCMAS":
              t = Generador.nuevaTemp();
              t2 = Generador.nuevaTemp();
            codigo = Generador.gc(Generador.ASIG, op1, null, t);
            codigo += Generador.gc(Generador.MAS, t, "1", t2);
            codigo += Generador.gc(Generador.ASIG, t2, null, op1);
            break;
        case "INCMENOS":
            t = Generador.nuevaTemp();
            t2 = Generador.nuevaTemp();
            codigo = Generador.gc(Generador.ASIG, op1, null, t);
            codigo += Generador.gc(Generador.MENOS, t, "1", t2);
            codigo += Generador.gc(Generador.ASIG, t2, null, op1);
            break;
        case "AND": 
            t = Generador.nuevaTemp();
            codigo = Generador.gc(Generador.AND, op1, op2, t);
            break;
        case "OR": 
            t = Generador.nuevaTemp();
            codigo = Generador.gc(Generador.OR, op1, op2, t);
            break;
        
        case "MAS": 
            t = Generador.nuevaTemp();
            codigo = Generador.gc(Generador.MAS, op1, op2, t);
            break;
        case "MENOS": 
            t = Generador.nuevaTemp();
            codigo = Generador.gc(Generador.MENOS, op1, op2, t);
            break;
        
        case "ASIG": 
            t = Generador.nuevaTemp();
            codigo = Generador.gc(Generador.ASIG, op1, op2, t);
            break;
        case "ASIG_DSC": 
            t = Generador.nuevaTemp();
            codigo = Generador.gc(Generador.ASIG, op1, null, t);
            break;*/
        }
    FCompiler.codigointermedio += codigo; 
    return t;
    }

    public Intermedio(java_cup.runtime.Scanner s,ArrayList<Error1> m,int fdl) {
        super(s); 
        ManejadorDeErrores = m;
        fl = fdl;
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        report_error("No se encontr√≥ ;",s);

    }

    public void syntax_error(Symbol s){
        //report_error("Sintactico",s);
    }

    public void report_error(String message, Object info){
        if(info!=null){
            java_cup.runtime.Symbol s =(java_cup.runtime.Symbol)info;
            String valor="";
            if(s.value!=null){
                valor = s.value.toString();
            }
        ManejadorDeErrores.add(new Error1(message,s.left,s.right,valor));
        }else{
            ManejadorDeErrores.add(new Error1(message,-1,-1,"?????"));
        }
    }

:};
   
  
/* ------------Declaracion de simbolos terminales y no terminales---------- */
   
/* Terminales (tokens obtenidos por el analizador lexico).  

   Terminales que no tienen un valor son listados primero, los terminales que
   tienen un valor como los enteros son listados en la segunda o demas lineas. */

terminal        DECLARE,CURLY_BR1,CURLY_BR2,SEMICOLON_SIGN,MAIN,ASSIG_OP,PARENTH1,PARENTH2,
                NOT,AND_OP,OR_OP,EQUAL_OP,GREATER_EQUAL_OP,LESS_EQUAL_OP,NOT_EQUAL_OP,LESS_OP,GREATER_OP,
                ADD_OP,SUBS_OP,STRING_WORD,INT_WORD,BOOLEAN_WORD,GROUP,NEW,COMMA_SIGN,MAX,MIN,NODE,FEATURES,
                BRACKET1,BRACKET2,IF,ELSE,LOOP,READFEATVAL,TRUE,FALSE,READSTRING,GENERATEGROUP,PRINTGRAPH,
                GETSIMILITUDE,GETFEATURES,ABSTRACTION,AFFABILITY,APPREHESION,ANXIETY,CARETOSTANDARDS,
                DARE,DOMINANCE,HARDNESS,INDEPENDENCE,SELFCONTROL,SELFSUFFICIENCY,SENSITIVITY,SOCIABILITY,STABILITY,
                STRESS,SURVEILLANCE,POINT_SIGN,ARRAYSTRING,PRINTLN,LIVELINESS,OPENNESSTOCHANGE,PERFECTIONISM,PRIVACY,
                REASONING,ERRORLEX;

terminal String  ID,STRING;
terminal Integer NUM;

/* No terminales usados en la seccion gramatical. 

   Primero se lista los no terminales que tienen un valor Object y despues
   se lista los no terminales que tienen un entero. Un Object se refiere a que
   no tienen tipo, pudiendo ser entero o String. */


non terminal        BEGIN,DECLARE_BODY,MAIN_BODY,DATA_TYPE,ASSIG,DEC,
                    EXP,STRINGVAL,BOOLEANVAL,COND,OP_ARIT,OP_LOG,OP_REL,BODY,NODE_STR,ARRAYSTRING_STR,
                    FEATURES_STR,CTRL_STR,GROUP_STR,MAXMIN,ARRAYVAL,FEATURESVAL,IF_STR,SENTEN,SENTENCES,INPUT,
                    OUTPUT,FUNCT,LOOP_STR,READFEAT,READS,PLN,GNGROUP,PGPH,GSIMILITUDE,GFEATURES,FEATURE_WORD,
                    STRINGVALAUX,INTVAL,EXPNUM,DECLARE_BODY2,DATA_STR,T,F;
 
precedence left AND_OP,OR_OP;
precedence left EQUAL_OP,GREATER_EQUAL_OP,LESS_EQUAL_OP,NOT_EQUAL_OP,LESS_OP,GREATER_OP;
precedence left ADD_OP, SUBS_OP;
precedence left CURLY_BR1,CURLY_BR2;
precedence left BRACKET1,BRACKET2;
precedence left PARENTH1,PARENTH2;

start with BEGIN;


BEGIN ::= DECLARE CURLY_BR1 DECLARE_BODY MAIN CURLY_BR1 MAIN_BODY CURLY_BR2;

/*----------------------GRAMATICAS DECLARE ---------------------*/

DECLARE_BODY ::=  CURLY_BR2 | DEC SEMICOLON_SIGN DECLARE_BODY | DATA_TYPE ASSIG SEMICOLON_SIGN DECLARE_BODY | ASSIG SEMICOLON_SIGN DECLARE_BODY ;

DECLARE_BODY2 ::= DEC SEMICOLON_SIGN | ASSIG SEMICOLON_SIGN | DATA_TYPE ASSIG SEMICOLON_SIGN ;

ASSIG ::= ID:miId ASSIG_OP EXP:v{:
    RESULT = parser.generarSinTemp("ASIG", v.toString(), miId.toString());:} ;

DATA_TYPE ::= STRING_WORD | INT_WORD | BOOLEAN_WORD ;

EXP ::=  ID 
| NUM:i {: RESULT=i; :} 
| TRUE:i{:RESULT=i;:} 
| FALSE:i {:RESULT=i;:} 
| STRINGVAL:i{:RESULT=i;:}  
| EXPNUM :i{:RESULT=i; :} 
| PARENTH1 EXP:i PARENTH2  {:RESULT=i;:}
| COND :i{:RESULT=i;:};

STRINGVAL ::= STRINGVALAUX:s1 {:
    if(s1!=null){
        RESULT=s1.toString();
    }
:} 
|  STRINGVALAUX:s1 ADD_OP STRINGVAL:s2 {:
    if(s1!=null && s2 !=null){
        String t= Generador.nuevaTemp();
        FCompiler.codigointermedio += Generador.gc(Generador.ADD_OP,s1.toString(),s2.toString(),t);
        RESULT=t;
    }
:};

STRINGVALAUX::= STRING:f{:
        String sincomillas= f.replace('"','-');
        sincomillas=sincomillas.replaceAll("-","");
        RESULT=sincomillas;
        parser.valorActual= f;
:} 
| ID:i{:
        
          TSDatos identificador=FCompiler.ts.buscar(i+"");
          parser.valorActual=identificador.valor.toString();
          parser.valorActual=identificador.valor;
          RESULT=identificador.valor;

:} ;

BOOLEANVAL ::= TRUE:i{:RESULT=i;:} 
| FALSE:i{:RESULT=i;:} 
| ID:i{:
        
          TSDatos identificador=FCompiler.ts.buscar(i+"");
          parser.valorActual=identificador.valor.toString();
          parser.valorActual=identificador.valor;
          RESULT=identificador.valor;

:};

OP_ARIT ::=  ADD_OP | SUBS_OP;

OP_LOG ::= AND_OP | OR_OP;


/*voy a ocupar una variable que cambie en cada caso, para saber que es*/
OP_REL ::= EQUAL_OP{: 
parser.op_relacional=1;
 :} 
| GREATER_EQUAL_OP{:
parser.op_relacional=2;
:} 
| LESS_EQUAL_OP{:
parser.op_relacional=3;
:} 
| NOT_EQUAL_OP{:
parser.op_relacional=4;
:} 
| LESS_OP{:
parser.op_relacional=5;
:} 
| GREATER_OP{:
parser.op_relacional=6;
:}
;


COND ::= F OP_LOG COND
{:

    //RESULT = parser.generar("SUBS_OPP", i.toString(), f.toString());

:} | EXPNUM:i OP_REL EXPNUM:f 
{:

RESULT = parser.generar("OP_REL", i.toString(), f.toString());

:} | F ;

F ::= BOOLEANVAL:i{: RESULT=i; :} | PARENTH1 COND PARENTH2;

EXPNUM ::=  T:e1 SUBS_OP EXPNUM:e2
{:
    RESULT = parser.generar("SUBS_OPP", e1.toString(), e2.toString()); 
:}
| T:e1 ADD_OP EXPNUM:e2 
{:
    RESULT = parser.generar("ADD_OP", e1.toString(), e2.toString()); 
:}
| T:e1 {:
    RESULT = e1;
:};

T ::= INTVAL:i{: RESULT=i; :} ;

INTVAL ::= NUM:i {: RESULT=i; :}  | ID:i {:
        
          TSDatos identificador=FCompiler.ts.buscar(i+"");
          parser.valorActual=identificador.valor.toString();
          parser.valorActual=identificador.valor;
          RESULT=identificador.valor;

:} ;

DEC ::= DATA_TYPE ID;

/*-------------------ESTRUCTURAS DE DATOS-- ---------------------*/  

DATA_STR::= NODE_STR | ARRAYSTRING_STR | FEATURES_STR | GROUP_STR;

GROUP_STR ::= GROUP ID ASSIG_OP NEW GROUP PARENTH1 ID COMMA_SIGN MAXMIN COMMA_SIGN ID PARENTH2 SEMICOLON_SIGN;

NODE_STR ::= NODE ID ASSIG_OP NEW NODE PARENTH1 ID COMMA_SIGN STRINGVAL COMMA_SIGN STRINGVAL PARENTH2 SEMICOLON_SIGN ;

ARRAYSTRING_STR ::=  ARRAYSTRING ID ASSIG_OP NEW BRACKET1 ARRAYVAL BRACKET2 SEMICOLON_SIGN;

ARRAYVAL ::= STRINGVAL | STRINGVAL COMMA_SIGN ARRAYVAL ;  

FEATURES_STR ::= FEATURES ID ASSIG_OP NEW FEATURES PARENTH1 FEATURESVAL PARENTH2 SEMICOLON_SIGN;

FEATURESVAL ::= EXPNUM COMMA_SIGN EXPNUM COMMA_SIGN EXPNUM COMMA_SIGN EXPNUM COMMA_SIGN EXPNUM COMMA_SIGN EXPNUM COMMA_SIGN EXPNUM COMMA_SIGN EXPNUM COMMA_SIGN EXPNUM COMMA_SIGN EXPNUM COMMA_SIGN EXPNUM COMMA_SIGN EXPNUM COMMA_SIGN EXPNUM COMMA_SIGN EXPNUM COMMA_SIGN EXPNUM COMMA_SIGN EXPNUM COMMA_SIGN EXPNUM COMMA_SIGN EXPNUM COMMA_SIGN EXPNUM COMMA_SIGN EXPNUM COMMA_SIGN EXPNUM;


/*-----------------GRAMATICAS MAIN, UY QUE MIEDO -------------------*/
MAIN_BODY ::= SENTEN |SENTEN MAIN_BODY; 


BODY ::= CURLY_BR2 | SENTEN BODY;

SENTENCES ::= SENTEN | SENTEN SENTENCES;

SENTEN ::= INPUT | OUTPUT | FUNCT | DATA_STR | DECLARE_BODY2 | CTRL_STR;


MAXMIN ::= MAX| MIN;

/***ENTRADA*****/

INPUT ::= READFEAT  | READS;

READFEAT ::= READFEATVAL PARENTH1 ID PARENTH2 SEMICOLON_SIGN;

READS ::= READSTRING PARENTH1 ID PARENTH2 SEMICOLON_SIGN;


/***SALIDA****/

OUTPUT ::= PLN  | GNGROUP | PGPH;

PLN ::= PRINTLN PARENTH1 STRINGVAL:val PARENTH2 SEMICOLON_SIGN{:
if(val!=null){String codigo = parser.generar("PRINTLN", "", val.toString());}

:};

GNGROUP ::= GENERATEGROUP PARENTH1 ID PARENTH2 SEMICOLON_SIGN;

PGPH ::= PRINTGRAPH PARENTH1 ID PARENTH2 SEMICOLON_SIGN;


/****FUNCIONES****/

FUNCT ::= GSIMILITUDE |  GFEATURES ;

GSIMILITUDE ::= GETSIMILITUDE PARENTH1 ID COMMA_SIGN ID PARENTH2 SEMICOLON_SIGN;

GFEATURES ::= GETFEATURES PARENTH1 ID POINT_SIGN FEATURE_WORD;


FEATURE_WORD ::= ABSTRACTION PARENTH2 SEMICOLON_SIGN
| AFFABILITY  PARENTH2 SEMICOLON_SIGN    
| APPREHESION PARENTH2 SEMICOLON_SIGN   
| ANXIETY PARENTH2 SEMICOLON_SIGN   
| CARETOSTANDARDS PARENTH2 SEMICOLON_SIGN    
| DARE PARENTH2 SEMICOLON_SIGN  
| DOMINANCE PARENTH2 SEMICOLON_SIGN 
| HARDNESS PARENTH2 SEMICOLON_SIGN 
| INDEPENDENCE PARENTH2 SEMICOLON_SIGN   
| LIVELINESS PARENTH2 SEMICOLON_SIGN 
| OPENNESSTOCHANGE PARENTH2 SEMICOLON_SIGN   
| PERFECTIONISM PARENTH2 SEMICOLON_SIGN  
| PRIVACY PARENTH2 SEMICOLON_SIGN   
| REASONING PARENTH2 SEMICOLON_SIGN  
| SELFCONTROL PARENTH2 SEMICOLON_SIGN  
| SELFSUFFICIENCY PARENTH2 SEMICOLON_SIGN    
| SENSITIVITY PARENTH2 SEMICOLON_SIGN   
| SOCIABILITY PARENTH2 SEMICOLON_SIGN   
| STABILITY PARENTH2 SEMICOLON_SIGN
| STRESS PARENTH2 SEMICOLON_SIGN 
| SURVEILLANCE PARENTH2 SEMICOLON_SIGN
;


/****CONTROL****/

CTRL_STR ::=  LOOP_STR | IF_STR;

IF_STR ::= IF PARENTH1 COND PARENTH2 CURLY_BR1 BODY | IF PARENTH1 COND PARENTH2 CURLY_BR1 BODY ELSE CURLY_BR1 BODY;

LOOP_STR ::= LOOP PARENTH1 COND PARENTH2 CURLY_BR1 BODY;
